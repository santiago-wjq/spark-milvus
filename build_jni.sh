#!/bin/bash

# JNI library build script
# For Linux environment

set -e

echo "Building JNI library for Spark application..."

# Set variables
JNI_SRC_DIR="src/main/c"
JNI_BUILD_DIR="target/native"
JNI_HEADER_DIR="target/jni-headers"
JAVA_HOME=${JAVA_HOME:-/usr/lib/jvm/default-java}
CPP_STANDARD="c++17"  # Use C++17 standard

# Check Java environment
if [ ! -d "$JAVA_HOME" ]; then
    echo "Error: JAVA_HOME not set or invalid: $JAVA_HOME"
    echo "Please set JAVA_HOME to your JDK installation directory"
    exit 1
fi

echo "Using JAVA_HOME: $JAVA_HOME"

# Create build directories
mkdir -p "$JNI_BUILD_DIR"
mkdir -p "$JNI_HEADER_DIR"
mkdir -p "src/main/resources/native"

# Clean previous builds
echo "Cleaning previous builds..."
rm -f "$JNI_BUILD_DIR"/*.so
rm -f "$JNI_HEADER_DIR"/*.h

# Compile Scala code to generate class files
echo "Compiling Scala code..."
sbt compile

# Generate JNI header files
echo "Generating JNI header files..."
CLASSPATH=$(sbt "export runtime:fullClasspath" | tail -n 1)

# Method 1: Try using javac -h (need to compile to .class files first)
echo "Trying to generate header with javac -h..."
CLASS_DIR="target/scala-2.13/classes"
if [ -f "$CLASS_DIR/com/zilliz/spark/connector/jni/NativeLib$.class" ]; then
    javac -h "$JNI_HEADER_DIR" -cp "$CLASSPATH" "$CLASS_DIR/com/zilliz/spark/connector/jni/NativeLib$.class" 2>/dev/null || {
        echo "javac -h with class file failed, trying alternative method..."
        # Method 2: Use javah (if available)
        if command -v javah &> /dev/null; then
            echo "Trying javah..."
            javah -classpath "$CLASSPATH" -d "$JNI_HEADER_DIR" com.zilliz.spark.connector.jni.NativeLib 2>/dev/null || {
                echo "javah failed, creating header file manually..."
                MANUAL_HEADER=true
            }
        else
            echo "javah not available, creating header file manually..."
            MANUAL_HEADER=true
        fi
    }
else
    echo "Class file not found, creating header file manually..."
    MANUAL_HEADER=true
fi

# Method 3: Create header file manually
if [ "$MANUAL_HEADER" = "true" ]; then
    echo "Creating header file manually..."
    cat > "$JNI_HEADER_DIR/com_zilliz_spark_connector_jni_NativeLib.h" << 'EOF'
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class example_jni_NativeLib */

#ifndef _Included_com_zilliz_spark_connector_jni_NativeLib
#define _Included_com_zilliz_spark_connector_jni_NativeLib
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_zilliz_spark_connector_jni_NativeLib$
 * Method:    getGreeting
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_zilliz_spark_connector_jni_NativeLib_00024_getGreeting
  (JNIEnv *, jobject);

/*
 * Class:     com_zilliz_spark_connector_jni_NativeLib$
 * Method:    processArray
 * Signature: ([I)[I
 */
JNIEXPORT jintArray JNICALL Java_com_zilliz_spark_connector_jni_NativeLib_00024_processArray
  (JNIEnv *, jobject, jintArray);

/*
 * Class:     com_zilliz_spark_connector_jni_NativeLib$
 * Method:    calculateSum
 * Signature: ([D)D
 */
JNIEXPORT jdouble JNICALL Java_com_zilliz_spark_connector_jni_NativeLib_00024_calculateSum
  (JNIEnv *, jobject, jdoubleArray);

/*
 * Class:     com_zilliz_spark_connector_jni_NativeLib$
 * Method:    processString
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_zilliz_spark_connector_jni_NativeLib_00024_processString
  (JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif
EOF
fi

# Check if header file was generated successfully
if [ ! -f "$JNI_HEADER_DIR/com_zilliz_spark_connector_jni_NativeLib.h" ]; then
    echo "Error: Failed to generate JNI header file"
    exit 1
fi

echo "Generated header file: $JNI_HEADER_DIR/com_zilliz_spark_connector_jni_NativeLib.h"

# Copy header file to src directory for development convenience
cp "$JNI_HEADER_DIR/com_zilliz_spark_connector_jni_NativeLib.h" "$JNI_SRC_DIR/"
echo "Copied header file to source directory for development: $JNI_SRC_DIR/com_zilliz_spark_connector_jni_NativeLib.h"

# Compile C++ code to shared library
echo "Compiling C++ code to shared library..."

# Check if C++ file exists
if [ -f "$JNI_SRC_DIR/mylibrary.cpp" ]; then
    echo "Found C++ source file, using g++ compiler..."
    g++ -shared -fPIC \
        -std="$CPP_STANDARD" \
        -O2 \
        -Wall \
        -Wextra \
        -I"$JAVA_HOME/include" \
        -I"$JAVA_HOME/include/linux" \
        -I"$JNI_HEADER_DIR" \
        -I"$JNI_SRC_DIR" \
        -o "$JNI_BUILD_DIR/libmylibrary.so" \
        "$JNI_SRC_DIR/mylibrary.cpp"
elif [ -f "$JNI_SRC_DIR/mylibrary.c" ]; then
    echo "Found C source file, using gcc compiler..."
    gcc -shared -fPIC \
        -O2 \
        -Wall \
        -I"$JAVA_HOME/include" \
        -I"$JAVA_HOME/include/linux" \
        -I"$JNI_HEADER_DIR" \
        -I"$JNI_SRC_DIR" \
        -o "$JNI_BUILD_DIR/libmylibrary.so" \
        "$JNI_SRC_DIR/mylibrary.c"
else
    echo "Error: No source file found (mylibrary.c or mylibrary.cpp)"
    exit 1
fi

# Check if compilation was successful
if [ ! -f "$JNI_BUILD_DIR/libmylibrary.so" ]; then
    echo "Error: Failed to compile shared library"
    exit 1
fi

echo "Successfully compiled: $JNI_BUILD_DIR/libmylibrary.so"

# Copy to resources directory (for jar packaging)
cp "$JNI_BUILD_DIR/libmylibrary.so" "src/main/resources/native/"
echo "Copied library to resources directory"

# Display library information
echo "Library information:"
file "$JNI_BUILD_DIR/libmylibrary.so"
ldd "$JNI_BUILD_DIR/libmylibrary.so" || true

echo ""
echo "JNI library build completed successfully!"
echo "Library location: $JNI_BUILD_DIR/libmylibrary.so"
echo ""
echo "To use the library, you can:"
echo "1. Set java.library.path: -Djava.library.path=$PWD/$JNI_BUILD_DIR"
echo "2. Or the library will be loaded from resources automatically"
echo ""